from config.database import get_database
from models.user_progress import UserQuestionHistory, OutcomeType
from typing import List, Dict
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class HistoryRepository:
    def __init__(self):
        self.db = get_database()
        self.collection = self.db.user_question_history
        # Ensure indexes for performance
        self.collection.create_index([("user_id", 1), ("theme_id", 1)])
        self.collection.create_index([("user_id", 1), ("question_id", 1)], unique=True)
    
    def upsert_interaction(self, user_id: str, question_id: str, theme_id: str, outcome: OutcomeType) -> None:
        """
        Update or insert a record of a user answering a question.
        Increments times_answered and updates last_seen/outcome.
        """
        now = datetime.utcnow()
        
        # Use find_one_and_update for atomic operation
        result = self.collection.find_one_and_update(
            {"user_id": user_id, "question_id": question_id},
            {
                "$set": {
                    "theme_id": theme_id,
                    "last_seen": now,
                    "outcome": outcome
                },
                "$inc": {"times_answered": 1},
                "$setOnInsert": {
                    # id is generated by model usually, but here we let mongo handle _id 
                    # or we could generate a UUID if we strictly need the 'id' field from our model
                    # For simplicity in this upsert, we might rely on mongo's _id or add one if needed by app logic
                    # Let's just rely on the fields we use.
                }
            },
            upsert=True,
            return_document=True
        )
        # Note: $setOnInsert doesn't work well for 'id' UUID generation inside mongo. 
        # If we really need a UUID 'id' for every doc, we might need a two-step process or client-side check.
        # However, for this look-up table, _id is sufficient or we can ignore the 'id' field requirement if purely internal.
        # To be safe with our Pydantic model which puts a default UUID, let's just do a check or accept that 
        # created docs via upsert might miss the explicit 'id' string field unless we provide it.
        # Given this is a join/history table, maybe we don't strictly need a public ID for the record itself yet.
    
    def get_user_history_by_themes(self, user_id: str, theme_ids: List[str]) -> Dict[str, dict]:
        """
        Get history for a user filtered by themes.
        Returns a dict mapping question_id -> history_data
        """
        cursor = self.collection.find(
            {
                "user_id": user_id,
                "theme_id": {"$in": theme_ids}
            },
            {"_id": 0, "question_id": 1, "last_seen": 1, "outcome": 1, "times_answered": 1}
        )
        
        history_map = {}
        for doc in cursor:
            history_map[doc["question_id"]] = doc
            
        return history_map
